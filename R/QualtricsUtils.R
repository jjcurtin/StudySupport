#NOTE:  These are support functions for apiGetSurvey
#They allow for download of Qualtrics surveys into R
#All code was ported (and then simplified for our specific usage) 
#from Jasper Ginn's qualtRics package
#because we had some problems with the the implementation some of the more complex
#aspects of his code that were unnecessary for our usage.
#
#None of these functions are intended for direct call.   All are used by
#apiGetSurvey()

#readSurvey()-------------------
#Read comma separated csv file from Qualtrics.
#
#Reads comma separated csvdata files generated by Qualtrics
#software. 

readSurvey = function(FileName) {
  
  #first row contains header, which are the variable names we want
  VarNames = read.csv(FileName, nrows=1)
  VarNames = names(VarNames)
  
  #read data but skip first 3 rows of header info
  dSurvey = read.csv(FileName,header=FALSE, skip = 3, as.is=TRUE)
  names(dSurvey) = VarNames
  
  
  #HANDLE Surveys with No data?
  
  # # If Qualtrics adds an empty column at the end, remove it
  # if(grepl(",$", readLines(file_name, n = 1))) {
  #   header = header[, 1:(ncol(header)-1)]
  #   rawdata = rawdata[, 1:(ncol(rawdata)-1)]
  # }
  
  # # clean variable labels (row 2)
  # 
  # if(stripHTML) {
  #   # weird regex to strip HTML tags, leaving only content
  #   # https://www.r-bloggers.com/htmltotext-extracting-text-from-html-via-xpath/ # nolint
  #   pattern = "</?\\w+((\\s+\\w+(\\s*=\\s*(?:\".*?\"|'.*?'|[^'\">\\s]+))?)+\\s*|\\s*)/?>" # nolint
  #   secondrow = gsub(pattern, "\\4", secondrow)
  # }
  # # Scale Question with subquestion:
  # # If it matches one of ".?!" followed by "-", take subsequent part
  # subquestions = stringr::str_match(secondrow, ".*[:punct:]\\s*-(.*)")[,2]
  # # Else if subquestion returns NA, use whole string
  # subquestions[is.na(subquestions)] = unlist(secondrow[is.na(subquestions)])
  # # Remaining NAs default to 'empty string'
  # subquestions[is.na(subquestions)] = ""
  return(dSurvey)
}



#createRawPayload()-----------------------
# Create raw JSON payload to post response exports request
# Returns json file with options to send to API

createRawPayload = function(surveyID,
                             useLabels=TRUE,
                             lastResponseId=NULL,
                             startDate=NULL,
                             endDate=NULL,
                             limit=NULL,
                             useLocalTime=FALSE,
                             seenUnansweredRecode=NULL,
                             includedQuestionIds = NULL) {
  
  str_c(
    '{"format": ', '"', 'csv', '"' ,
    ', "surveyId": ', '"', surveyID, '"',
    ifelse(
      is.null(lastResponseId),
      "",
      str_c(
        ', "lastResponseId": ',
        '"',
        lastResponseId,
        '"')
    ) ,
    ifelse(
      is.null(startDate),
      "",
      str_c(
        ', "startDate": ',
        '"',
        str_c(startDate,"T00:00:00Z"),
        '"')
    ) ,
    ifelse(
      is.null(endDate),
      "",
      str_c(
        ', "endDate": ',
        '"',
        str_c(endDate,"T00:00:00Z"),
        '"')
    ) ,
    ifelse(
      is.null(seenUnansweredRecode),
      "",
      str_c(
        ', "seenUnansweredRecode": ',
        '"',
        seenUnansweredRecode,
        '"')
    ),
    ifelse(
      !useLocalTime,
      "",
      str_c(
        ', "useLocalTime": ',
        tolower(useLocalTime)
      )
    ),
    ifelse(
      is.null(includedQuestionIds),
      "",
      str_c(
        ', "includedQuestionIds": ',
        '[', paste0('"',includedQuestionIds, '"', collapse=", "), ']'
      )
    ),
    ifelse(
      is.null(limit),
      "",
      str_c(
        ', "limit": ',
        limit
      )
    ),
    ', ',
    '"useLabels": ', tolower(useLabels),
    '}'
  )
}

#qualtricsAPIRequest()------------------
# Send httr requests to qualtrics API
#
# @param verb type of request to be sent (@seealso ?httr::VERB)
# @param url qualtrics endpoint url created by appendRootUrl() function
# @param body options created by createRawPayload() function
#


qualtricsAPIRequest = function(APIToken, verb = c("GET", "POST"), URL,
                                body = NULL) {
  # Match arg
  verb = match.arg(verb)
  
  # Construct header
  headers = constructHeader(APIToken)
  
  # Send request to qualtrics API (httr functions)
  res = VERB(verb,
                    url = URL,
                    add_headers(
                      headers
                    ),
                    body = body)
  
  # Check if response type is OK
  cnt = qualtRicsResponseCodes(res)
  
  # Check if OK
  if(cnt$OK) {
    # If notice occurs, raise warning
    w = checkForWarnings(cnt)
    
    # return content
    return(cnt$content)
  }
}

#constructHeader()-----------------
# Construct a header to send to qualtrics API

constructHeader = function(APIToken) {
  # Construct and return
  headers = c(
    'X-API-TOKEN' = APIToken,
    'Content-Type' = "application/json",
    'Accept' = '*/*',
    'accept-encoding' = 'gzip, deflate'
  )
  return(headers)
}


#qualtRicsResponseCodes()-------------------------
# Checks responses against qualtrics response codes and returns error message.
#
# res response from httr::GET
# raw if TRUE, add 'raw' flag to httr::content() function.

qualtRicsResponseCodes = function(res, raw=FALSE) {
  # Check status code and raise error/warning
  if(res$status_code == 200) {
    if(raw) {
      result = content(res, "raw")
    } else {
      result = content(res)
    }
    return(list(
      "content" = result,
      "OK" = TRUE
    )
    )
  } else if(res$status_code == 401) {
    stop("Qualtrics API raised an authentication (401) error - you may not have the required authorization. Please check your API key and root url.") # nolint
  } else if(res$status_code == 400) {
    stop("Qualtrics API raised a bad request (400) error - Please report this on https://github.com/JasperHG90/qualtRics/issues") # nolint
  } else if(res$status_code == 404) {
    stop("Qualtrics API complains that the requested resource cannot be found (404 error). Please check if you are using the correct survey ID.") # nolint
  } else if(res$status_code == 500) {
    stop(paste0("Qualtrics API reports an internal server (500) error. Please contact Qualtrics Support (https://www.qualtrics.com/contact/) and provide the instanceId and errorCode below.", "\n", # nolint
                "\n",
                "instanceId:", " ",
                content(res)$meta$error$instanceId,
                "\n",
                "errorCode: ",
                content(res)$meta$error$errorCode))
    return(list(
      "content" = content(res),
      "OK"= FALSE
    ))
  } else if(res$status_code == 503) {
    stop(paste0("Qualtrics API reports a temporary internal server (500) error. Please contact Qualtrics Support (https://www.qualtrics.com/contact/) with the instanceId and errorCode below or retry your query.", "\n", # nolint
                "\n",
                "instanceId:", " ", content(res)$meta$error$instanceId,
                "\n",
                "errorCode: ", content(res)$meta$error$errorCode))
    return(list(
      "content" = content(res),
      "OK"= FALSE
    )
    )
  } else if(res$status_code == 413) {
    stop("The request body was too large. This can also happen in cases where a multipart/form-data request is malformed.") # nolint
  } else if(res$status_code == 429) {
    stop("You have reached the concurrent request limit.")
  }
}

#checkForWarnings()----------------------------
# Check if httr GET result contains a warning
#
# resp object returned by 'qualtRicsResponseCodes()'

checkForWarnings = function(resp) {
  # Raise warning if resp contains notice
  if(!is.null(resp$content$meta)) {
    if(!is.null(resp$content$meta$notice)) {
      warning(resp$content$meta$notice)
    }
  }
  NULL
}




#downloadQualtricsExport---------------------
# Download response export
#
# CheckURL url provided by qualtrics API that shows the download percentage completneness

downloadQualtricsExport = function(CheckURL, APIToken) {
  # Construct header
  headers = constructHeader(APIToken)
  
  # Create a progress bar and monitor when export is ready
  pbar = utils::txtProgressBar(min=0,max=100,style = 3)
  
  # While download is in progress
  progress = 0
  while(progress < 100) {
    # Get percentage complete
    CU = qualtricsAPIRequest(APIToken,"GET", URL = CheckURL)
    progress = CU$result$percentComplete
    
    # Set progress
    utils::setTxtProgressBar(pbar, progress)
  }
  
  # Kill progress bar
  close(pbar)
  
  # Download file
  f = tryCatch({
    GET(str_c(CheckURL, "/file"), add_headers(headers))
  }, error = function(e) {
    # Retry if first attempt fails
    GET(str_c(CheckURL, "/file"), add_headers(headers))
  })
  
  # # If content is test request, then load temp file (this is purely for testing)
  # # httptest library didn't work the way it needed and somehow still called the API
  # # leading to errors
  # if(f$request$url == "t.qualtrics.com/API/v3/responseexports/T_123/file"){
  #   if(f$request$headers["X-API-TOKEN"] == "1234") {
  #     ct = readRDS("files/file_getSurvey.rds")
  #     f$content = ct
  #   }
  # }
  # #browser()
  
  # Load raw zip file
  ty = qualtRicsResponseCodes(f, raw=TRUE)
  
  # To zip file
  tf = file.path(tempdir(), 'temp.zip')
  
  # Write to temporary file
  writeBin(ty$content, tf)
  
  # Try to unzip
  u = tryCatch({
    utils::unzip(tf, exdir = tempdir())
  }, error = function(e) {
    stop(str_c("Error extracting ",
                "csv",
                " from zip file. Please re-run your query."))
  })
  
  # Remove zipfile
  p = file.remove(tf)
  
  # Return file location
  return(u)
}